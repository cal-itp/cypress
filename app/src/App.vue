<template>
  <header>
    <h1>Cypress - Find Grants</h1>
  </header>

  <main>
    <cypress-grants-form :customers="customers" :beneficiaries="beneficiaries" :projectTypes="projectTypes" v-model="applicantInfo"></cypress-grants-form>
    <cypress-grants-list :grants="grants" :applicant-info="applicantInfo"></cypress-grants-list>
  </main>
</template>

<script>
import CypressGrantsForm from './components/CypressGrantsForm.vue';
import CypressGrantsList from './components/CypressGrantsList.vue';
import { papaParsePromise } from './utils';

export default {
  data() {
    return {
      customers: [],

      /*
        Each grant will have the following attributes from the table:
        - key
        - name
        - organization_type

        Additionally, each of the following attributes will be added to each
        grant by joining from additional tables:
        - eligiblePrimaryApplicantTypes (array of strings)
        - eligibleProjectBeneficiaries (array of strings)
        - eligibleProjectTypes (array of {type, needsAdditionalReview})
        - eligibilityCriteria (array of strings)
      */
      grants: [],
      applicantInfo: { projectBeneficiaries: [], projectTypes: [] },
    }
  },

  methods: {
    async fetchCustomers() {
      /* The customers dataset was generated by exporting the following query:

          select
            key,
            name,
            organization_type,
            -- The following should all be determined for real, but for now we'll
            -- just randomly assign them (the fingerprint will be effectively
            -- random, but stable).
            mod(farm_fingerprint(name || 'a'), 2) = 0 as has_service_to_non_urbanized_area,  -- Check against Census UAC data?
            case when mod(farm_fingerprint(name || 'b'), 3) = 0 then true
                when mod(farm_fingerprint(name || 'b'), 3) = 1 then false
                else null end as has_service_connecting_urban_areas,
            mod(farm_fingerprint(name || 'c'), 2) = 0 as has_service_in_non_attainment_area,  -- Check against EPA NAAQS data?
            mod(farm_fingerprint(name || 'd'), 2) = 0 as can_receive_state_transit_assistance,
            mod(farm_fingerprint(name || 'e'), 2) = 0 as has_service_along_freight_corridors,
        from staging_mart_transit_database.dim_organizations
        where _valid_to > current_timestamp

      */
      const results = await papaParsePromise('/stub_data/customers.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      });
      this.customers = results.data.map((row) => {
        const trinary = {
          'true': true,
          'false': false,
          'null': null,
          '': null,
        };

        return {
          ...row,
          has_service_to_non_urbanized_area: trinary[row.has_service_to_non_urbanized_area],
          has_service_connecting_urban_areas: trinary[row.has_service_connecting_urban_areas],
          has_service_in_non_attainment_area: trinary[row.has_service_in_non_attainment_area],
          can_receive_state_transit_assistance: trinary[row.can_receive_state_transit_assistance],
          has_service_along_freight_corridors: trinary[row.has_service_along_freight_corridors],
        }
      });
    },

    async fetchGrants() {
      const grants = (await papaParsePromise('/stub_data/grants.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      })).data;

      function groupBy(key) {
        return (acc, row) => {
          acc[row[key]] = acc[row[key]] || [];
          acc[row[key]].push(row);
          return acc;
        }
      }

      const grantEligiblePrimaryApplicantTypes = (await papaParsePromise('/stub_data/grant_eligible_primary_applicant_types.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      }))
      .data
      .reduce(groupBy('grant_name'), {});

      const grantEligibleBeneficiaries = (await papaParsePromise('/stub_data/grant_eligible_beneficiaries.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      }))
      .data
      .reduce(groupBy('grant_name'), {});

      const grantEligibleProjectTypes = (await papaParsePromise('/stub_data/grant_eligible_project_types.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      }))
      .data
      .reduce(groupBy('grant_name'), {});

      const grantEligibilityCriteria = (await papaParsePromise('/stub_data/grant_eligibility_criteria.csv', {
        header: true,
        download: true,
        skipEmptyLines: true,
      }))
      .data
      .reduce(groupBy('grant_name'), {});

      for (const grant of grants) {
        grant.eligiblePrimaryApplicantTypes = (grantEligiblePrimaryApplicantTypes[grant.name] || []).map(row => row.entity_type);
        grant.eligibleProjectBeneficiaries = (grantEligibleBeneficiaries[grant.name] || []).map(row => row.beneficiary);
        grant.eligibleProjectTypes = (grantEligibleProjectTypes[grant.name] || []).map(row => ({ type: row.project_type, needsAdditionalReview: row.needs_additional_review === 'TRUE' }));
        grant.eligibilityCriteria = (grantEligibilityCriteria[grant.name] || []).map(row => row.eligibility_code);
      }

      this.grants = grants;
    },
  },

  computed: {
    beneficiaries() {
      return [
        ...new Set(this.grants.flatMap(grant => grant.eligibleProjectBeneficiaries)),
      ];
    },

    projectTypes() {
      return [
        ...new Set(this.grants.flatMap(grant => grant.eligibleProjectTypes.map(t => t.type))),
      ];
    },
  },

  components: {
    'cypress-grants-form': CypressGrantsForm,
    'cypress-grants-list': CypressGrantsList,
  },

  created() {
    this.fetchCustomers();
    this.fetchGrants();
  },
}
</script>

<style scoped>
header {
  line-height: 1.5;
}

main {
  display: flex;
  flex-direction: row;
  gap: 1rem;
}
</style>
